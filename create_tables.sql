-- Создаём таблицу "Materials" - материалы
-- Первичному ключу даём название "Id" и говорим, что он должен генерироваться самостоятельно базой данных (+ дописываем CONSTRAINT "PK_Materials" PRIMARY KEY ("Id") соблюдая конфенцию о именовании CONSTRAINT описывающих первичные ключи)
-- Даём имя материалу - "Name", это обязательная информация, так что указываем NOT NULL, а также чтобы не ограничивать пользователей используем character varying(1000), пусть лучше база поднапряжётся, но наши запросы будут выглоядет чище, а пользователи будут довольны
-- Столбец "Measurement" - описывает единицы изменения материала, он вряд ли будет очень большим, выделим 100 знаков под него (character varying(100)), эта информация обязательна (NOT NULL)
-- "PlanPrice" - плановая цена на материал, должна быть числом с плавающей запятой, даём пользователю максимальную свободу - используем numberic (до 131072 знаков до запятой, и 16383 после), эта информация обязательна (NOT NULL)
CREATE TABLE "Materials" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "Name" character varying(1000) NOT NULL,
    "Measurement" character varying(100) NOT NULL,
    "PlanPrice" numeric NOT NULL,
    CONSTRAINT "PK_Materials" PRIMARY KEY ("Id")
    CHECK ("PlanPrice" > 0)
);

-- По аналогии с первой таблицей строим таблицы соблюдая конвенции и стараясь максимально угодить пользователю

-- Таблица деталей
-- Id - автоматически генерируемый первичный ключ
-- DetailType - Тип детали (обязательный параметр)  
-- Name - Название детали (обязательный параметр) (максимальный размер - 2000 символов)
-- Measurement - Единицы измерения детали (обязательный параметр) (максимальный размер - 500 символов) ('шт' например)
-- PlanPrice - Плановая стоимость детали (обязательный параметр)
CREATE TABLE "Parts" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "DetailType" integer NOT NULL,
    "Name" character varying(2000) NOT NULL,
    "Measurement" character varying(500) NOT NULL,
    "PlanPrice" numeric NOT NULL,
    CONSTRAINT "PK_Parts" PRIMARY KEY ("Id")
);

-- Таблица профессий
-- Id - автоматически генерируемый первичный ключ
-- Name - Название профессии (обязательный параметр) (максимальный размер - 1000 символов)
CREATE TABLE "Professions" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "Name" character varying(1000) NOT NULL,
    CONSTRAINT "PK_Professions" PRIMARY KEY ("Id")
);

-- Таблица профессий
-- Id - автоматически генерируемый первичный ключ
-- PerHour - Тарифная ставка (обязательный параметр)
CREATE TABLE "Tarifs" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "PerHour" numeric NOT NULL,
    CONSTRAINT "PK_Tarifs" PRIMARY KEY ("Id")
);

-- В отличии от прошлых таблиц следующие имеют внешние ключи, следуя конвенции начинаем названия CONSTRAINT с FK, а также применяем ON DELETE CASCADE для автоматического (каскадного) удаления строк из базы при удалении родительских сущностей

-- Таблица операций
-- Id - автоматически генерируемый первичный ключ
-- PartId - Обязательный внешний ключ с каскадным удалением (ссылка на таблицу деталей) (ОДИН КО МНОГИМ относительно таблицы деталей, то есть на одну деталь много операций)
-- MaterialId - Обязательный внешний ключ с каскадным удалением (ссылка на таблицу материалов) (ОДИН КО МНОГИМ относительно таблицы материалов, то есть на один материал много операций)
-- NeededAmount - Необходимое количество материала (обязательное)
CREATE TABLE "Operations" (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "PartId" integer NOT NULL,
    "MaterialId" integer NOT NULL,
    "NeededAmount" numeric NOT NULL,
    CONSTRAINT "PK_Operations" PRIMARY KEY ("Id"),
    CONSTRAINT "FK_Operations_Materials_MaterialId" FOREIGN KEY ("MaterialId") REFERENCES "Materials" ("Id") ON DELETE CASCADE,
    CONSTRAINT "FK_Operations_Parts_PartId" FOREIGN KEY ("PartId") REFERENCES "Parts" ("Id") ON DELETE CASCADE
);

-- Здесь используем составной ключ, потому столбец "Id" не нужен

-- Таблица пооперационных нормы затрат труда на изготовление
-- PartId - Обязательный внешний ключ с каскадным обновлением (ссылка на таблицу деталей)
-- Не до конца ясно зачем нужен PartId, так как его мы можем достать и из таблицы операций. Но продолжаем идти по ТЗ
-- OperationId - Обязательный внешний ключ с каскадным удалением (ссылка на таблицу операций)
-- ProfessionId - Обязательный внешний ключ с каскадным удалением (ссылка на таблицу профессий)
-- TarifId - Обязательный внешний ключ с каскадным удалением (ссылка на таблицу тарифов)
-- Qualification - квалификационный разряд рабочего (обязательное текстовое поле с максимальным размеров в 2000 символов)
-- FinalMinuteTime - время подготовительно-заключительное (в мин.);
-- PieceMinuteTime - время штучное (в мин.).
-- Не забываем  описать каскадный ключ состоящий из 4 внешних: PartId, OperationId, ProfessionId, TarifId
CREATE TABLE "Norms" (
    "PartId" integer NOT NULL,
    "OperationId" integer NOT NULL,
    "ProfessionId" integer NOT NULL,
    "TarifId" integer NOT NULL,
    "Qualification" character varying(2000) NOT NULL,
    "FinalMinuteTime" numeric NOT NULL,
    "PieceMinuteTime" numeric NOT NULL,
    CONSTRAINT "PK_Norms" PRIMARY KEY ("PartId", "OperationId", "ProfessionId", "TarifId"),
    CONSTRAINT "FK_Norms_Operations_OperationId" FOREIGN KEY ("OperationId") REFERENCES "Operations" ("Id") ON UPDATE CASCADE,
    CONSTRAINT "FK_Norms_Parts_PartId" FOREIGN KEY ("PartId") REFERENCES "Parts" ("Id") ON DELETE CASCADE,
    CONSTRAINT "FK_Norms_Professions_ProfessionId" FOREIGN KEY ("ProfessionId") REFERENCES "Professions" ("Id") ON DELETE CASCADE,
    CONSTRAINT "FK_Norms_Tarifs_TarifId" FOREIGN KEY ("TarifId") REFERENCES "Tarifs" ("Id") ON DELETE CASCADE
);

-- Создаём индексы, продолжая придерживаться конвенций (начинаем с IX). Индексы создаём только для самых вероятных использваний - внешних ключей

CREATE INDEX "IX_Norms_OperationId" ON "Norms" ("OperationId");
CREATE INDEX "IX_Norms_ProfessionId" ON "Norms" ("ProfessionId");
CREATE INDEX "IX_Norms_TarifId" ON "Norms" ("TarifId");
CREATE INDEX "IX_Norms_PartId" ON "Norms" ("PartId");
CREATE INDEX "IX_Operations_MaterialId" ON "Operations" ("MaterialId");
CREATE INDEX "IX_Operations_PartId" ON "Operations" ("PartId");

-- Создаём процедуру для частичного наполнения БД
-- Задаём ей имя Init
-- Обозначем, что пишем на SQL (Странно если бы здесь писали на чём-то ином)
-- Между AS $$ и $$ вписываем комманды, которые хотим выполнить, в нашем случае - INSERT

CREATE PROCEDURE Init()
LANGUAGE SQL
AS $$
INSERT INTO "Materials"("Name", "Measurement", "PlanPrice") VALUES('Тестовый материал 1','кг',11.0);
INSERT INTO "Materials"("Name", "Measurement", "PlanPrice") VALUES('Тестовый материал 2','кг',12.0);
INSERT INTO "Materials"("Name", "Measurement", "PlanPrice") VALUES('Тестовый материал 3','кг',13.0);
INSERT INTO "Materials"("Name", "Measurement", "PlanPrice") VALUES('Тестовый материал 4','кг',14.0);
INSERT INTO "Materials"("Name", "Measurement", "PlanPrice") VALUES('Тестовый материал 5','кг',15.0);
INSERT INTO "Materials"("Name", "Measurement", "PlanPrice") VALUES('Тестовый материал 6','кг',16.0);

INSERT INTO "Professions"("Name") VALUES('Тестовый кадр 1');
INSERT INTO "Professions"("Name") VALUES('Тестовый кадр 2');
INSERT INTO "Professions"("Name") VALUES('Тестовый кадр 3');
INSERT INTO "Professions"("Name") VALUES('Тестовый кадр 4');
INSERT INTO "Professions"("Name") VALUES('Тестовый кадр 5');
INSERT INTO "Professions"("Name") VALUES('Тестовый кадр 6');

INSERT INTO "Tarifs"("Name", "PerHour") VALUES('Тестовый тариф 1', 100);
INSERT INTO "Tarifs"("Name", "PerHour") VALUES('Тестовый тариф 2', 101);
INSERT INTO "Tarifs"("Name", "PerHour") VALUES('Тестовый тариф 3', 102);
INSERT INTO "Tarifs"("Name", "PerHour") VALUES('Тестовый тариф 4', 103);
INSERT INTO "Tarifs"("Name", "PerHour") VALUES('Тестовый тариф 5', 104);
INSERT INTO "Tarifs"("Name", "PerHour") VALUES('Тестовый тариф 6', 105);

INSERT INTO "Parts"("Name", "DetailType", "Measurement", "PlanPrice") VALUES('Тестовая деталь 1', 0, "кг", 12.7);
INSERT INTO "Parts"("Name", "DetailType", "Measurement", "PlanPrice") VALUES('Тестовая деталь 2', 1, "кг", 100.9);
INSERT INTO "Parts"("Name", "DetailType", "Measurement", "PlanPrice") VALUES('Тестовая деталь 3', 0, "кг", 17564);
INSERT INTO "Parts"("Name", "DetailType", "Measurement", "PlanPrice") VALUES('Тестовая деталь 4', 1, "кг", 987.2);
INSERT INTO "Parts"("Name", "DetailType", "Measurement", "PlanPrice") VALUES('Тестовая деталь 5', 0, "кг", 50.2);

INSERT INTO "Operations"("PartId", "MaterialId", "NeededAmount") VALUES(1, 1, 1);
INSERT INTO "Operations"("PartId", "MaterialId", "NeededAmount") VALUES(1, 2, 2);
INSERT INTO "Operations"("PartId", "MaterialId", "NeededAmount") VALUES(2, 3, 3);
INSERT INTO "Operations"("PartId", "MaterialId", "NeededAmount") VALUES(2, 4, 4);
INSERT INTO "Operations"("PartId", "MaterialId", "NeededAmount") VALUES(3, 5, 5);

INSERT INTO "Norms"("PartId", "OperationId", "ProfessionId", "TarifId", "Qualification", "FinalMinuteTime", "PieceMinuteTime") VALUES(1, 1, 1, 1, 'Тестовая квалификация 1', 1, 1);
INSERT INTO "Norms"("PartId", "OperationId", "ProfessionId", "TarifId", "Qualification", "FinalMinuteTime", "PieceMinuteTime") VALUES(1, 2, 2, 2, 'Тестовая квалификация 2', 2, 2);
INSERT INTO "Norms"("PartId", "OperationId", "ProfessionId", "TarifId", "Qualification", "FinalMinuteTime", "PieceMinuteTime") VALUES(2, 3, 3, 3, 'Тестовая квалификация 3', 3, 3);
INSERT INTO "Norms"("PartId", "OperationId", "ProfessionId", "TarifId", "Qualification", "FinalMinuteTime", "PieceMinuteTime") VALUES(2, 4, 4, 4, 'Тестовая квалификация 4', 4, 4);
INSERT INTO "Norms"("PartId", "OperationId", "ProfessionId", "TarifId", "Qualification", "FinalMinuteTime", "PieceMinuteTime") VALUES(3, 5, 5, 5, 'Тестовая квалификация 5', 5, 5);
$$;
